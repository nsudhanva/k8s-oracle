# CLAUDE.md - AI Assistant Guidelines for k3s-oracle

This document provides essential context and safety guidelines for AI assistants working on this repository.

## Important note

The idea is to use this repo to create the cluster where this repo:

- This repo represents 100% of the cluster
- This repo is the source of truth for the cluster via argocd and terraform
- We are gonna be following the docs and code used in this repo to create the cluster.
- The user of this repo will follow the docs to use this repo. If in case you plan to do any ad-hoc changes to the cluster to fix an intermediate issue, please make the changes in this repo so we do not run into any issues when we re-build the cluster from scratch, also update documentation to reflect the changes.

## Project Overview

This project provisions a **3-node K3s cluster on Oracle Cloud Infrastructure (OCI) Always Free tier** using:

- **Terraform** for infrastructure provisioning
- **ArgoCD** for GitOps-based deployments
- **Envoy Gateway** for ingress (Gateway API)
- **External Secrets Operator** with OCI Vault for secrets management
- **Cert Manager** for Let's Encrypt TLS certificates
- **External DNS** for Cloudflare DNS automation

## Critical Safety Rules

### 1. NEVER Commit Secrets

- **terraform.tfvars** - Contains all sensitive credentials (gitignored)
- **terraform.tfstate** - Contains infrastructure state with secrets - this needs to be stored in OCI Bucket
- OCI API keys, Cloudflare tokens, GitHub PATs are stored in OCI Vault
- Always check `git diff --staged` before committing

### 2. NEVER Run kubectl apply Directly

- All Kubernetes resources MUST be deployed via ArgoCD
- Modify manifests in `argocd/` directory and push to Git
- ArgoCD will sync changes automatically
- Direct `kubectl apply` bypasses GitOps and causes drift

### 3. Terraform Safety

```bash
# ALWAYS run plan first
terraform plan -out=tfplan

# Review the plan carefully before applying
terraform apply tfplan

# NEVER run these without explicit user confirmation:
# - terraform destroy
# - terraform apply -auto-approve
# - Any command that shows "will be destroyed" in red
```

### 4. Donts

- Do not add inline comments to YAML files
- Do not make changes as your please as this repository is directly connected to the cluster
- Do not use helm install manually; let ArgoCD handle Helm charts
- Do not hardcode versions without researching the latest stable release
- Do not delete PVCs or any data volumes without explicit user approval

### 5. Yeses

- Add any required documentation under docs/
- Commit small, logical changes with descriptive messages. Use brief commit messages.
- Always search online for latest stable versions before adding dependencies
- Always use Vault to store sensitive information or secrets
- Always use ArgoCD to deploy applications

**Dangerous Terraform patterns to avoid:**

- Removing `lifecycle { prevent_destroy = true }` from production resources
- Changing resource names (causes destroy + recreate)
- Modifying `availability_domain` (recreates instances)
- Changing `cidr_block` on VCN/subnets (network disruption)

### 4. Secrets Management

- All secrets go to OCI Vault (managed by Terraform in `vault.tf`)
- Kubernetes secrets are synced via External Secrets Operator
- Never hardcode secrets in manifests - use ExternalSecret CRs
- Template files (`.tpl`) may contain `${variable}` placeholders - these are NOT secrets

## Repository Structure

```
k3s-oracle/
├── tf-k3s/                    # Terraform infrastructure code
│   ├── *.tf                   # Terraform configuration files
│   ├── cloud-init/            # VM bootstrap scripts
│   └── templates/manifests/   # ArgoCD manifest templates
├── argocd/                    # GitOps manifests (generated by Terraform)
│   ├── applications.yaml      # Root ArgoCD Application manifest
│   ├── infrastructure/        # Platform components
│   └── apps/                  # Application deployments
├── docs/                      # Astro documentation site
└── .github/workflows/         # CI/CD pipelines
```

## Common Operations

### Accessing the Cluster

```bash
# SSH to server via ingress jump host
ssh -J ubuntu@<ingress-public-ip> ubuntu@10.0.2.10

# Run kubectl commands
ssh -J ubuntu@<ingress-public-ip> ubuntu@10.0.2.10 "sudo kubectl get nodes"

# Start SSH tunnel for local kubectl
ssh -N -L 16443:10.0.2.10:6443 ubuntu@<ingress-public-ip>
```

### Checking ArgoCD Status

```bash
ssh -J ubuntu@<ingress-public-ip> ubuntu@10.0.2.10 "sudo kubectl get applications -n argocd"
```

### Deploying Changes

1. Modify manifests in `argocd/` or templates in `tf-k3s/templates/manifests/`
2. If templates changed, run `terraform apply` to regenerate manifests
3. Commit and push to Git
4. ArgoCD syncs automatically (or manually via UI/CLI)

## Infrastructure Details

### Nodes

| Node | IP | Resources | Role |
|------|-----|-----------|------|
| k3s-ingress | 10.0.1.10 (public) | 1 OCPU, 6GB | NAT + Envoy Gateway |
| k3s-server | 10.0.2.10 (private) | 2 OCPU, 12GB | Control plane + ArgoCD |
| k3s-worker | 10.0.2.x (private) | 1 OCPU, 6GB | Workloads |

### Network

- VCN CIDR: 10.0.0.0/16
- Public subnet: 10.0.1.0/24 (ingress node)
- Private subnet: 10.0.2.0/24 (server + worker)
- Private nodes use ingress node as NAT gateway

## Required terraform.tfvars Variables

```hcl
# OCI Authentication (NOT stored in Vault - needed to access Vault)
tenancy_ocid     = "ocid1.tenancy.oc1..."
user_ocid        = "ocid1.user.oc1..."
fingerprint      = "xx:xx:xx..."
private_key_path = "/path/to/oci_api_key.pem"
region           = "us-ashburn-1"
compartment_ocid = "ocid1.compartment.oc1..."

# SSH Key
ssh_public_key_path = "/path/to/ssh_key.pub"

# Cloudflare (stored in Vault)
cloudflare_api_token = "..."
cloudflare_zone_id   = "..."
domain_name          = "k3s.example.com"

# GitHub (stored in Vault)
git_repo_url  = "https://github.com/username/k3s-oracle.git"
git_username  = "username"
git_pat       = "ghp_..."
git_email     = "user@example.com"

# Cluster Config (stored in Vault)
argocd_admin_password = "..."
acme_email            = "admin@example.com"
k3s_token             = "random-secure-token"
```

## Troubleshooting

### Out of Capacity Error

OCI ARM instances have limited availability. Try:

- Different availability domain (change index in `compute.tf`)
- Different region (requires new tenancy setup)
- Retry later (capacity fluctuates)

### Pods Can't Resolve DNS

OCI Ubuntu images have restrictive iptables. Cloud-init should fix this, but if needed:

```bash
sudo iptables -P INPUT ACCEPT
sudo iptables -P FORWARD ACCEPT
sudo iptables -F
sudo netfilter-persistent save
```

### ArgoCD Not Syncing

1. Check ArgoCD can reach GitHub: verify repo-creds secret exists
2. Check applications status: `kubectl get applications -n argocd`
3. Check ArgoCD logs: `kubectl logs -n argocd -l app.kubernetes.io/name=argocd-server`

## Pre-Deployment Checklist

Before running `terraform apply` for the first time:

1. [ ] OCI account with Always Free eligibility verified
2. [ ] OCI API key generated and configured
3. [ ] Cloudflare API token with Zone.DNS Edit permissions
4. [ ] GitHub PAT with `repo` and `read:packages` scopes
5. [ ] SSH key pair generated (ed25519 recommended)
6. [ ] Domain pointed to Cloudflare nameservers
7. [ ] `terraform.tfvars` created with all required variables
8. [ ] Region has ARM instance availability checked

## Post-Deployment Steps

1. Wait ~5 minutes for cloud-init to complete
2. Push generated `argocd/` manifests to Git
3. Verify all ArgoCD applications are Synced/Healthy
4. Test DNS resolution and HTTPS access
5. Access ArgoCD UI at `https://cd.k3s.sudhanva.me`
6. Access docs app at `https://k3s.sudhanva.me`

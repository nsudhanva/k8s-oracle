# CLAUDE.md - AI Assistant Guidelines for k8s-oracle

This document provides essential context and safety guidelines for AI assistants working on this repository.

## Important note

The idea is to use this repo to create the cluster where this repo:

- This repo represents 100% of the cluster
- This repo is the source of truth for the cluster via argocd and terraform
- We are gonna be following the docs and code used in this repo to create the cluster.
- The user of this repo will follow the docs to use this repo. If in case you plan to do any ad-hoc changes to the cluster to fix an intermediate issue, please make the changes in this repo so we do not run into any issues when we re-build the cluster from scratch, also update documentation to reflect the changes.

## Project Overview

This project provisions an **OKE (Oracle Kubernetes Engine) Basic cluster on Oracle Cloud Infrastructure (OCI) Always Free tier** using:

- **Terraform** for infrastructure provisioning
- **OKE Basic Cluster** - Free managed Kubernetes control plane
- **ARM-based worker nodes** - 2 nodes with 2 OCPU/12GB each (4 OCPUs, 24GB total)
- **ArgoCD** for GitOps-based deployments
- **Envoy Gateway** for ingress (Gateway API) with OCI LoadBalancer
- **External Secrets Operator** with OCI Vault for secrets management
- **Cert Manager** for Let's Encrypt TLS certificates
- **External DNS** for Cloudflare DNS automation

## Critical Safety Rules

### 1. NEVER Commit Secrets

- **terraform.tfvars** - Contains all sensitive credentials (gitignored)
- **terraform.tfstate** - Contains infrastructure state with secrets - this needs to be stored in OCI Bucket
- OCI API keys, Cloudflare tokens, GitHub PATs are stored in OCI Vault
- Always check `git diff --staged` before committing

### 2. NEVER Run kubectl apply Directly

- All Kubernetes resources MUST be deployed via ArgoCD
- Modify manifests in `argocd/` directory and push to Git
- ArgoCD will sync changes automatically
- Direct `kubectl apply` bypasses GitOps and causes drift

### 3. Terraform Safety

```bash
# ALWAYS run plan first
terraform plan -out=tfplan

# Review the plan carefully before applying
terraform apply tfplan

# NEVER run these without explicit user confirmation:
# - terraform destroy
# - terraform apply -auto-approve
# - Any command that shows "will be destroyed" in red
```

### 4. Donts

- Do not add inline comments to YAML files
- Do not make changes as your please as this repository is directly connected to the cluster
- Do not use helm install manually; let ArgoCD handle Helm charts
- Do not hardcode versions without researching the latest stable release
- Do not delete PVCs or any data volumes without explicit user approval

### 5. Yeses

- Add any required documentation under docs/
- Commit small, logical changes with descriptive messages. Use brief commit messages.
- Always search online for latest stable versions before adding dependencies
- Always use Vault to store sensitive information or secrets
- Always use ArgoCD to deploy applications

**Dangerous Terraform patterns to avoid:**

- Removing `lifecycle { prevent_destroy = true }` from production resources
- Changing resource names (causes destroy + recreate)
- Modifying `availability_domain` (recreates instances)
- Changing `cidr_block` on VCN/subnets (network disruption)

### 6. Secrets Management

- All secrets go to OCI Vault (managed by Terraform in `vault.tf`)
- Kubernetes secrets are synced via External Secrets Operator
- Never hardcode secrets in manifests - use ExternalSecret CRs
- Template files (`.tpl`) may contain `${variable}` placeholders - these are NOT secrets

## Repository Structure

```text
k8s-oracle/
├── tf-oke/                    # Terraform infrastructure code
│   ├── *.tf                   # Terraform configuration files
│   └── templates/manifests/   # ArgoCD manifest templates
├── argocd/                    # GitOps manifests (generated by Terraform)
│   ├── applications.yaml      # Root ArgoCD Application manifest
│   ├── infrastructure/        # Platform components
│   └── apps/                  # Application deployments
├── docs/                      # Astro documentation site
└── .github/workflows/         # CI/CD pipelines
```

## Required terraform.tfvars Variables

```hcl
# OCI Authentication (NOT stored in Vault - needed to access Vault)
tenancy_ocid     = "ocid1.tenancy.oc1..."
user_ocid        = "ocid1.user.oc1..."
fingerprint      = "xx:xx:xx..."
private_key_path = "/path/to/oci_api_key.pem"
region           = "us-ashburn-1"
compartment_ocid = "ocid1.compartment.oc1..."

# SSH Key
ssh_public_key_path = "/path/to/ssh_key.pub"

# Cloudflare (stored in Vault)
cloudflare_api_token = "..."
cloudflare_zone_id   = "..."
domain_name          = "k8s.example.com"

# GitHub (stored in Vault)
git_repo_url  = "https://github.com/username/k8s-oracle.git"
git_username  = "username"
git_pat       = "ghp_..."
git_email     = "user@example.com"

# Cluster Config (stored in Vault)
argocd_admin_password = "..."
acme_email            = "admin@example.com"
```

## OKE Cluster Configuration

The OKE cluster uses the following defaults (configurable via variables):

- **Kubernetes Version**: 1.32.1
- **Cluster Type**: BASIC_CLUSTER (free managed control plane)
- **Node Pool**: 2 ARM nodes (VM.Standard.A1.Flex)
- **Node Config**: 2 OCPU, 12GB RAM per node
- **Total Resources**: 4 OCPUs, 24GB RAM (max free tier)

## Pre-Deployment Checklist

Before running `terraform apply` for the first time:

1. [ ] OCI account upgraded to Pay-As-You-Go (required for OKE)
2. [ ] OCI API key generated and configured
3. [ ] Cloudflare API token with Zone.DNS Edit permissions
4. [ ] GitHub PAT with `repo` and `read:packages` scopes
5. [ ] SSH key pair generated (ed25519 recommended)
6. [ ] Domain pointed to Cloudflare nameservers
7. [ ] `terraform.tfvars` created with all required variables
8. [ ] Region has ARM instance availability checked

## Post-Deployment Steps

1. Wait for OKE cluster to be ACTIVE (can take 10-15 minutes)
2. Generate kubeconfig:

   ```bash
   oci ce cluster create-kubeconfig --cluster-id <cluster-ocid> \
     --file $HOME/.kube/config --region <region> \
     --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT
   ```

3. Push generated `argocd/` manifests to Git
4. Install ArgoCD:

   ```bash
   kubectl create namespace argocd
   kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
   kubectl apply -f argocd/applications.yaml
   ```

5. Wait for LoadBalancer IP to be assigned to Envoy Gateway
6. Verify all ArgoCD applications are Synced/Healthy
7. Test DNS resolution and HTTPS access
